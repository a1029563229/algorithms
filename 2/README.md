# 算法基础

## 背包、队列和栈

- 背包：背包是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。
- 队列：先进先出队列（或简称队列）是一种基于先进先出（FIFO）策略的集合类型；
- 下压栈（或简称栈）是一种基于后进先出（LIFO）策略的集合类型；

## 算法分析

- 程序在不同的计算机上运行时间之比通常是一个常数。
- 一个程序运行的总时间主要和两点有关
  - 执行每条语句的耗时；
  - 执行每条语句的效率；

### 增长数量级的分类

- 常数级别（1）
  - 普通语句、将两个数相加；
  - 运行时间的增长数量级为常数的程序完成它的任务所需的操作次数一定，因此它的运行时间不依赖于 N。大多数的 Java 操作所需的时间均为常数；
- 对数级别（log N）
  - 二分策略、二分查找；
  - 运行时间的增长数量级为对数的程序仅比常数时间的程序稍慢。运行时间和问题规模成对数关系的程序的经典例子就是二分查找。
- 线性级别（N）
  - 单循环、找出最大元素；
  - 使用常数时间处理输入数据中的所有元素或是基于单个 for 循环的程序是十分常见的。此类程序的增长数量级是线性的——它的运行时间和 N 成正比。
- 线性对数级别（N log N）
  - 分治、归并排序；
  - 我们用线性对数描述运行时间和问题规模 N 的关系为 NlogN 的程序。
- 平方级别（N^2）
  - 双层循环、检查所有元素对、初级排序算法；
  - 一个运行时间的增长数量级为 N^2 的程序一般都含有两个嵌套的 for 循环，对由 N 个元素得到的所有元素对进行计算。
- 立方级别（N^3）
  - 三层循环、检查所有三元组；
  - 一个运行时间的增长数量级为 N^3 的程序一般都含有三个嵌套的 for 循环，对由 N 个元素得到的所有三元组进行计算；
- 指数级别（2^N）
  - 穷举查找、检查所有子集；
  - 我们一般会使用指数级别来描述增长数量级为 b^N 的算法，其中 b > 1 且为常数；
  - 指数级别的算法非常慢，不太可能用它们来解决大规模的问题；